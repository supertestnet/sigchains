While revising my sigchain proposal, I kept running into issues regarding what exactly I need to store in the sigchain.

It initially seemed like all the sigchain needed was signatures, hence the name. Given a message and a pubkey, it is possible to use those -- plus a signature -- to verify that the signature was validly created from the pubkey for the given message.

However, it wasn't long before I realized that if the pubkey is only given at the time of message verification, it allows the pubkey owner to doublespend. All he would need to do is add a signature to the sigchain in which, for his pubkey, he sends the money to himself, then create another signature sending the money to someone else. Once he shows that second signature to the victim, the victim will verify that it signs a message sending the money to himself, but he won't know that the pubkey in question already signed a message sending the money to himself.

When I first thought of that problem I wondered if the victim could resolve this doublespend problem by checking every signature on the sigchain against a given pubkey to see if the signature is valid for a prior message. If it is, then he found one or more messages, he could tell the sender, "Hey, show me these other messages first so I can make sure you didn't send all your tokens away already."

But that would introduce lots of problems, one of which is how to do it in a time efficient manner once there are many signatures on the sigchain. Users should have some way to narrow down the amount of signatures they have to check. With this in mind, I decided to make it so that they only have to check the first signature they find that is valid for a given pubkey, and -- to ensure they don't have to skim through the entire sigchain checking each one as they go -- I could make it a rule that each signature on the sigchain must have its pubkey prefixed to it. Then you could query the sigchain for only the set of signatures containing a prefix matching your sender's pubkey, and treat only the first one as valid.

However, this idea resulted in a new limitation: the sigchain now needs signatures --AND-- pubkeys. And, given that pubkeys are 32 bytes, signatures are 64 bytes, and op_returns can only hold 80 bytes, this also meant that a sigchain entry could not be entered to the sigchain via op_return using only one op_return. At that point I decided that the *full* pubkey didn't need to get added to the sigchain, it's only being used as a key to narrow down the number of sigchain entries you need to scan. So I decided it's okay if only part of the pubkey is prefixed to the signature. A 64 byte signature leaves us with 16 bytes left in an op_return field, so the first 16 bytes of each pubkey should do just fine.

Then I came up with a new problem: censorship. If there is a rule that only the first sigchain entry containing a certain pubkey is valid, and if -- to avoid censorship -- a user must always retain the ability to bypass the sigchain oracle by adding their signature to bitcoin's blockchain, the sigchain oracle must not be able to invalidate transactions that attempt to bypass him. But he could. All he would need to do is watch for sigchain entries that enter the mempool, then create a fake entry for the pubkey that is trying to bypass him and submit that pubkey with a junk signature.

This would be censorship for anyone who assumes that only the first message signed by a given pubkey is true. They would see an entry for that pubkey before the other one got confirmed and say "Hey, your second entry is invalid because it's not the first." Even if I got rid of the "only the first is valid" rule, the user would still need to know if the junk transaction sent away the sender's balance, so they need proof that it's not junk. But you can't prove that the signature --is-- junk unless you know what message it's suposed to be a signature for. And the recipient can't just ask the sender to give him a message to check the signature against since the sender be giving him the "wrong" message so as to dupe him into thinking the signature is invalid.

At this point I realized that what needs to go on the sigchain is not only a pubkey (or part of one) and not only a signature, but also the message itself. And this flummoxed me. I was already out of room in an 80 byte op return because it has a 16 byte partial pubkey and a 64 byte signature. Given that the messages sigchain users are expected to put on the sigchain are hashes, and hashes are 32 bytes, I didn't know hat to do. There was just no more room.

At that point it occurred to me that sha256 hashes are 32 bytes but there are other algorithms that produce shorter hashes. Ripemd160, for example, produces 20 byte hashes. This gave me an idea: what if the user put a 20 byte hash, a 16 byte pubkey, and a 64 byte signature on the sigchain? Well, no, that's no good, it's still 100 bytes -- 20 bytes too many for an op_return. At that point I decided to use data addresses instead of op_returns because you can add more data to the blockchain per transaction that way, but it's considered chain spam especially since it not only adds it to the blockchain but also to the chainstate (unlike op_return, which only adds data to the blockchain and can therefore be pruned).

Even later, it occurred to me that there are cryptography schemes that do not create 64 byte signatures. In fact, if you use ECDSA signatures over the secp160r1 curve, you get 20 byte pubkeys and 40 byte signatures. Combined with a 20 byte message (or rather the ripemd160 hash of a message), that would be 80 bytes and should fit into an op_return. Huzzah! A solution!

I found some javascript [here](https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/8.0.4/jsrsasign-all-min.js) which lets you do this stuff and instructions [here](https://www.devildoxx.com/web-development/algorithms/generate-ecdsa-signature/) which I had to modify. Specifically, his instructions say to use the curve "secp256r1" (which I had to change to secp160r1) and he also says to use the signature algorithm "SHA256withECDSA" (which I had to change to RIPEMD160withECDSA). The rest worked...well...sort of.

I found two problems that resulted from this: the pubkey appears to be 41 bytes (I want 20) and the signature appears to be 46 bytes (I want 40). The pubkey appears to be 41 bytes because it always has an initial byte of 04 that indicates that it is an uncompressed pubkey, and that term -- uncompressed pubkey -- means it is the X coordinate of the pubkey plus the Y coordinate. A compressed pubkey is just the y coordinate. (A compressed pubkey is supposed to be preceded by an 02 if it's an even number or an 03 if it's odd.)

To use a compressed pubkey (which is the 20 bytes I need) I think I need to have the person who adds the entry to the sigchain only add the y coordinate (i.e. the last 20 bytes) and then the verifier recompute what the X coordinate is and prefix an 03 to it. Then they can run the signature verification function to verify that the signature is valid. I haven't tested this yet but it should work I hope.

The second issue is that the signature is not 40 bytes, it is 46 bytes. After reading a github exchange [here](https://github.com/kjur/jsrsasign/issues/116) I discovered the first of the 46 bytes is always 30, so that can be discarded and prefixed by the verifier later. The second byte indicates the length of the r_value of the signature in bytes, which can vary somewhat even though it's always represented as 20 hexadecimal digits (when converted to hexadecimal). But since I know it's always 20 hexadecimal digits I can discard that too, bringing us down to 44 bytes. Again, the verifier can compute the length later and prefix that part himself.

The next byte is always 02 which is used as a separator. It can be discarded and re-added by the verifier later, bringing us down to 42 bytes. Then follow 20 bytes of hexadecimal (the r_value of the signature) indicating the message after it's been hashed using the RIPEMD160withECDSA algothithm.

Then follows another 02 which, again, is a separator that can be discarded and added back later by the verifier. Now we're at 41 bytes. The last byte to be removed indicates the length, in bytes, of the s_value of the signature. Like the previous length indicator, it can be removed and re-computed by the verifier and added back in later.

So there it is, now I'm down to a 40 byte signature! Combined with the 20 byte message and the 20 byte pubkey, that should all fit in one single op_return. Censorship resistance for the sigchain at last, in something pretty efficient space-wise! Now I just need to implement all of this remove-now, compute-later stuff and make sure it all works. And then I have a bunch more work to do. But hey, it's a start!

Oh yeah, I forgot to mention a few other things. Besides the pubkey, message, and signature, another thing I want to store in the sigchain is a timestamp. But this is irrelevant in regard to op_returns because it can be computed by the verifier later using the header of the block the op_return is included in. More relevantly, the proposal says there should also be a sigchain id in the op_return which consists of a 20 byte ripemd160 hash of the oracle's pubkey. It's supposed to let verifiers know which sigchain they will add a given transaction to, assuming there are more than one.

Fitting another 20 bytes into an op_return that is already full might be challenging, so I now wonder if there's another way to do sigchain ids. For some background on my new solution (before I name it), I observe that 1 byte can be one of 256 different values and I assume that it is easy to use brute force to generate a ripemd160 hash of a message and ensure that its first byte is customizable, provided that your message has a "nonce" field where you can add arbitrary text and keep checking what the hash is until the first byte matches the value you want. Given these observations and assumptions, perhaps the sigchain id can be inferred using the first byte of the message hash. The creator of the message would have to put a nonce field into his message and brute force-ly add text to it and hash it til the first byte matches what he wants, but this would allow 256 different sigchains without needing to squeeze more data into the op_return. So I think it's okay.

Another thing I am currently realizing while writing this missive is that the r_value of the signature is actually the ripemd160 hash of the message and the s_value is the signature proper. Both of these are only 20 bytes. Consequently I don't need to hash my message before running it through the signature algorithm, the signature algrithm will produce a "signature" that includes an r_value (my message's hash) and an s_value (the signature proper). Thus I was basically including an extra hash in the op_return that is not necessary. I don't need a 20 byte pubkey, a 20 byte hash, and a 40 byte signature, because the signature itself is really a 20 byte hash and a 20 byte signature. So maybe I can use the chain id again instead of the "first" 20 byte hash -- or I can keep using the "256 sigchains" idea and make it so that op_returns only need to add 60 bytes of data to the blockchain instead of 80, which would help reduce criticisms by those who may think sigchains themselves will produce too much chain spam.

And now I'm realizing that the previous paragraph is incorrect, I do need the 20 byte hash and then the 40 byte signature, despite the fact that the 40 byte signature will contain a hash of a hash. The purpose of including the message in the sigchain is so that one can verify that the signature is not junk. To do that, one needs to run the message through a verification algorithm, which, among other things, hashes the message and checks if the result matches the hash in the signature. If, then, I don't include the message which needs to be hashed, future verifiers won't know if a message given to them -- which does not hash to that value -- is just a decoy and there is a "real" Message which does hash to the expected value. So I need to include the message itslef, even though it's just a hash, and not rely on on the fact that there is also a hash of that hash in the signature. Therefore there can still be only 256 sigchains unless some other clever trick occurs to me, like also making wallets use brute force the first byte of their pubkey to yield 256^2 potential sigchains.
